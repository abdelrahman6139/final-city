const XLSX = require('xlsx');
const { PrismaClient } = require('@prisma/client');
const fs = require('fs');

const prisma = new PrismaClient();

const BRANDS = ['TOTAL', 'CROWN', 'INGCO', 'BOSCH', 'JADEVER', 'WADFFO', 'APT'];

// Global report data
const globalReport = {
    brands: {},
    summary: {
        totalProcessed: 0,
        totalInserted: 0,
        totalSkipped: 0,
        totalErrors: 0,
        duplicateCodesRemoved: 0,
        duplicateBarcodesSetNull: 0,
        emptyBarcodesKeptNull: 0,
        crossBrandBarcodeConflicts: 0,
        noNameSkipped: 0,
        codesAutoGenerated: 0,
        emptyItemTypesCreated: 0
    }
};

// ====================================================================================
// VALIDATION & PREPROCESSING
// ====================================================================================
function preprocessBrandData(brandName) {
    console.log(`\nðŸ“‹ Preprocessing ${brandName}...`);

    const workbook = XLSX.readFile('./prisma/test.xlsx');
    const worksheet = workbook.Sheets[brandName];

    if (!worksheet) {
        console.log(`âŒ Sheet "${brandName}" not found!`);
        return null;
    }

    const rawData = XLSX.utils.sheet_to_json(worksheet, { defval: '' });

    let currentCategory = null;
    let currentSubcategory = null;
    let currentItemType = null;

    const products = [];
    const itemTypesFound = []; // Track ALL ItemTypes (even empty ones)
    const subcategoriesFound = []; // â­ NEW: Track all subcategories
    const codeMap = new Map();
    const barcodeMap = new Map();
    const generatedBarcodeMap = new Map(); // â­ Track generated barcodes globally

    let rowNumber = 1;

    for (const row of rawData) {
        rowNumber++;

        const category = (row['Category'] || '').toString().trim();
        const subcategory = (row['Subcategory'] || '').toString().trim();
        const itemType = (row['ItemType'] || '').toString().trim();
        const productName = (row['ProductName'] || '').toString().trim();
        let code = (row['CODE'] || '').toString().trim();
        let barcode = (row['Barcode'] || '').toString().trim();
        const cost = parseFloat(row['COST']) || 0;
        const quantity = parseInt(row['Quantity']) || 0;

        // Track hierarchy
        if (category) {
            currentCategory = category;
            continue;
        }

        if (subcategory) {
            currentSubcategory = subcategory;
            currentItemType = null;

            subcategoriesFound.push({
                category: currentCategory,
                subcategory: currentSubcategory
            });
            continue;
        }

        if (itemType && currentSubcategory) {
            currentItemType = itemType;

            // â­ Track ItemType even if no products follow
            itemTypesFound.push({
                category: currentCategory,
                subcategory: currentSubcategory,
                itemType: currentItemType
            });

            continue;
        }

        // PRODUCT ROW
        if (currentCategory && currentSubcategory && currentItemType) {
            const product = {
                rowNumber,
                category: currentCategory,
                subcategory: currentSubcategory,
                itemType: currentItemType,
                name: productName,
                code: code,
                originalCode: code,
                barcode: barcode,
                originalBarcode: barcode,
                cost: cost,
                quantity: quantity,
                issues: []
            };

            // Validate product name
            if (!productName) {
                product.issues.push('NO_NAME');
            }

            // â­ Auto-generate CODE if missing
            if (!code) {
                code = `TEST-${Date.now()}-${Math.random().toString(36).substr(2, 6).toUpperCase()}`;
                product.code = code;
                product.issues.push('CODE_AUTO_GENERATED');
            }
            if (!barcode) {
                // Generate base barcode from hierarchy
                const hierarchyString = `${currentCategory}-${currentSubcategory}-${currentItemType}`;
                let generatedBarcode = hierarchyString.replace(/[^a-zA-Z0-9]/g, '').toUpperCase();

                // Check if this generated barcode already exists
                if (!generatedBarcodeMap.has(generatedBarcode)) {
                    generatedBarcodeMap.set(generatedBarcode, 0);
                }

                const count = generatedBarcodeMap.get(generatedBarcode);

                if (count > 0) {
                    // Add DUPL1, DUPL2, etc.
                    generatedBarcode = `${generatedBarcode}DUPL${count}`;
                }

                // Increment counter for next duplicate
                generatedBarcodeMap.set(generatedBarcode.replace(/DUPL\d+$/, ''), count + 1);

                barcode = generatedBarcode;
                product.barcode = generatedBarcode;
                product.issues.push('BARCODE_AUTO_GENERATED');
            }

            // Track codes
            if (!codeMap.has(code)) codeMap.set(code, []);
            codeMap.get(code).push(product);

            // Track barcodes (only if not empty)
            if (barcode) {
                if (!barcodeMap.has(barcode)) barcodeMap.set(barcode, []);
                barcodeMap.get(barcode).push(product);
            } else {
                product.issues.push('EMPTY_BARCODE');
            }

            // Check other fields
            if (cost === 0) product.issues.push('MISSING_COST');
            if (quantity === 0) product.issues.push('ZERO_QUANTITY');

            products.push(product);
        }
    }

    // Find duplicate CODES - remove entire product
    const duplicateCodes = [];
    const productsToRemove = new Set();

    for (const [code, prods] of codeMap.entries()) {
        if (prods.length > 1) {
            // Skip if all are auto-generated codes (they're unique)
            const allAutoGenerated = prods.every(p => p.issues.includes('CODE_AUTO_GENERATED'));
            if (!allAutoGenerated) {
                duplicateCodes.push({ code, products: prods });
                prods.forEach(p => productsToRemove.add(p));
            }
        }
    }

    // â­ Find duplicate BARCODES - set barcode to null, keep product
    const duplicateBarcodes = [];
    const productsWithNullifiedBarcodes = [];


    for (const [barcode, prods] of barcodeMap.entries()) {
        if (prods.length > 1) {
            // Only nullify if NOT auto-generated (auto-generated already have DUPL suffix)
            const allAutoGenerated = prods.every(p => p.issues.includes('BARCODE_AUTO_GENERATED'));

            if (!allAutoGenerated) {
                duplicateBarcodes.push({ barcode, products: prods });
                prods.forEach(p => {
                    if (!p.issues.includes('BARCODE_AUTO_GENERATED')) {
                        p.barcode = null;
                        p.issues.push('BARCODE_SET_NULL_DUE_TO_DUPLICATE');
                        productsWithNullifiedBarcodes.push(p);
                    }
                });
            }
        }
    }

    // Filter valid products
    const validProducts = products.filter(p => {
        if (!p.name) return false; // Skip products without names
        if (productsToRemove.has(p)) return false; // Skip duplicate codes
        return true;
    });


    const skippedNoName = products.filter(p => !p.name);
    const autoGeneratedCodes = validProducts.filter(p => p.issues.includes('CODE_AUTO_GENERATED'));
    const autoGeneratedBarcodes = validProducts.filter(p => p.issues.includes('BARCODE_AUTO_GENERATED'));

    console.log(`  Total rows processed: ${products.length}`);
    console.log(`  Valid products: ${validProducts.length}`);
    console.log(`  Skipped (no name): ${skippedNoName.length}`);
    console.log(`  Auto-generated codes: ${autoGeneratedCodes.length}`);
    console.log(`  Auto-generated barcodes: ${autoGeneratedBarcodes.length}`);
    console.log(`  Duplicate codes: ${duplicateCodes.length} (${duplicateCodes.reduce((sum, d) => sum + d.products.length, 0)} products REMOVED)`);
    console.log(`  Duplicate barcodes: ${duplicateBarcodes.length} (${productsWithNullifiedBarcodes.length} barcodes SET TO NULL)`);
    console.log(`  ItemTypes found: ${itemTypesFound.length}`);

    return {
        products,
        validProducts,
        skippedNoName,
        duplicateCodes,
        duplicateBarcodes,
        productsRemovedDueToCodes: Array.from(productsToRemove),
        productsWithNullifiedBarcodes,
        autoGeneratedCodes,
        autoGeneratedBarcodes,
        itemTypesFound,
        subcategoriesFound
    };
}

// ====================================================================================
// SEED PRODUCTS
// ====================================================================================
async function seedBrand(brandName, validationData) {
    if (!validationData) return null;

    console.log(`\nðŸ“¦ Seeding ${brandName}...`);

    const { validProducts, itemTypesFound, subcategoriesFound } = validationData; // â­ Add subcategoriesFound

    let totalInserted = 0;
    let errors = [];
    let barcodeConflicts = [];
    let emptyItemTypesCreated = [];
    let emptySubcategoriesCreated = []; // â­ NEW

    // Get references
    const mainBranch = await prisma.branch.findFirst({ where: { code: 'BR001' } });
    const mainWarehouse = await prisma.stockLocation.findFirst({
        where: { branchId: mainBranch.id, name: 'Main Warehouse' }
    });
    const adminUser = await prisma.user.findFirst({ where: { username: 'admin' } });

    // Build hierarchy from itemTypesFound (includes empty ones)
    const hierarchy = {};

    for (const sub of subcategoriesFound) {
        if (!hierarchy[sub.category]) {
            hierarchy[sub.category] = {};
        }
        if (!hierarchy[sub.category][sub.subcategory]) {
            hierarchy[sub.category][sub.subcategory] = {};
        }
    }

    for (const item of itemTypesFound) {
        if (!hierarchy[item.category]) {
            hierarchy[item.category] = {};
        }
        if (!hierarchy[item.category][item.subcategory]) {
            hierarchy[item.category][item.subcategory] = {};
        }
        if (!hierarchy[item.category][item.subcategory][item.itemType]) {
            hierarchy[item.category][item.subcategory][item.itemType] = [];
        }
    }

    // Add products to hierarchy
    for (const product of validProducts) {
        if (!hierarchy[product.category]) {
            hierarchy[product.category] = {};
        }
        if (!hierarchy[product.category][product.subcategory]) {
            hierarchy[product.category][product.subcategory] = {};
        }
        if (!hierarchy[product.category][product.subcategory][product.itemType]) {
            hierarchy[product.category][product.subcategory][product.itemType] = [];
        }
        hierarchy[product.category][product.subcategory][product.itemType].push(product);
    }

    // Create hierarchy and insert products
    for (const [catName, subcats] of Object.entries(hierarchy)) {
        let categoryObj = await prisma.category.findFirst({ where: { name: catName } });
        if (!categoryObj) {
            categoryObj = await prisma.category.create({
                data: { name: catName, nameAr: catName, active: true }
            });
        }

        for (const [subName, itemTypes] of Object.entries(subcats)) {
            let subcategoryObj = await prisma.subcategory.findFirst({
                where: { categoryId: categoryObj.id, nameAr: subName }
            });
            if (!subcategoryObj) {
                subcategoryObj = await prisma.subcategory.create({
                    data: {
                        categoryId: categoryObj.id,
                        name: subName,
                        nameAr: subName,
                        active: true
                    }
                });
            }
            if (Object.keys(itemTypes).length === 0) {
                emptySubcategoriesCreated.push({
                    category: catName,
                    subcategory: subName
                });
            }

            for (const [itemName, products] of Object.entries(itemTypes)) {
                let itemTypeObj = await prisma.itemType.findFirst({
                    where: { subcategoryId: subcategoryObj.id, nameAr: itemName }
                });

                if (!itemTypeObj) {
                    itemTypeObj = await prisma.itemType.create({
                        data: {
                            subcategoryId: subcategoryObj.id,
                            name: itemName,
                            nameAr: itemName,
                            active: true
                        }
                    });
                }

                // â­ Track empty ItemTypes
                if (products.length === 0) {
                    emptyItemTypesCreated.push({
                        category: catName,
                        subcategory: subName,
                        itemType: itemName
                    });
                }

                // Insert products
                for (const p of products) {
                    try {
                        let barcodeToUse = p.barcode;
                        let barcodeConflictInfo = null;

                        // CHECK: Does barcode already exist in database (cross-brand conflict)?
                        if (barcodeToUse) {
                            const existingBarcode = await prisma.product.findUnique({
                                where: { barcode: barcodeToUse },
                                include: { category: true }
                            });

                            if (existingBarcode) {
                                // Barcode exists in another brand - ADD DUPL
                                barcodeConflictInfo = {
                                    rowNumber: p.rowNumber,
                                    productName: p.name,
                                    code: p.code,
                                    originalBarcode: p.originalBarcode,
                                    modifiedBarcode: `${barcodeToUse}DUPL`,
                                    conflictBrand: existingBarcode.category.name,
                                    conflictProduct: existingBarcode.nameAr,
                                    subcategory: p.subcategory,
                                    itemType: p.itemType
                                };

                                barcodeToUse = `${barcodeToUse}DUPL`; // Add DUPL suffix
                                barcodeConflicts.push(barcodeConflictInfo);
                            }
                        }

                        // â­ If barcode is null, keep it null (no generation)

                        const product = await prisma.product.create({
                            data: {
                                code: p.code,
                                barcode: barcodeToUse, // â­ Can be null
                                nameEn: p.name, // Use Arabic name for both fields
                                nameAr: p.name, // Use Arabic name for both fields
                                categoryId: categoryObj.id,
                                itemTypeId: itemTypeObj.id,
                                brand: catName,
                                cost: p.cost,
                                costAvg: p.cost,
                                priceRetail: p.cost,
                                priceWholesale: p.cost,
                                unit: 'PCS',
                                active: true
                            }
                        });

                        // Add stock if quantity > 0
                        if (p.quantity > 0) {
                            await prisma.stockMovement.create({
                                data: {
                                    productId: product.id,
                                    stockLocationId: mainWarehouse.id,
                                    qtyChange: p.quantity,
                                    movementType: 'ADJUSTMENT',
                                    notes: `Initial stock from ${brandName} seed`,
                                    createdBy: adminUser.id
                                }
                            });
                        }

                        totalInserted++;
                        if (totalInserted % 20 === 0) {
                            process.stdout.write(`\r  âœ“ Inserted ${totalInserted}...`);
                        }

                    } catch (error) {
                        let reason = error.message;
                        let conflictBrand = null;

                        if (error.code === 'P2002') {
                            // Unique constraint violation
                            if (error.meta?.target?.includes('code')) {
                                // Code conflict
                                const existing = await prisma.product.findUnique({
                                    where: { code: p.code },
                                    include: { category: true }
                                });
                                if (existing) {
                                    conflictBrand = existing.category.name;
                                    reason = `Code already exists in ${conflictBrand}`;
                                }
                            } else if (error.meta?.target?.includes('barcode')) {
                                reason = 'Barcode (with DUPL suffix) still exists in database';
                            }
                        }

                        errors.push({
                            rowNumber: p.rowNumber,
                            product: p.name,
                            code: p.code,
                            barcode: p.originalBarcode || 'NULL',
                            subcategory: p.subcategory,
                            itemType: p.itemType,
                            error: reason,
                            conflictBrand: conflictBrand
                        });
                    }
                }
            }
        }
    }

    console.log(`\n  âœ… Successfully inserted: ${totalInserted} products`);
    if (barcodeConflicts.length > 0) {
        console.log(`  âš ï¸ Barcode conflicts (cross-brand): ${barcodeConflicts.length} (added DUPL suffix)`);
    }
    if (emptySubcategoriesCreated.length > 0) {
        console.log(`  ðŸ“ Empty Subcategories created: ${emptySubcategoriesCreated.length}`);
    }
    if (emptyItemTypesCreated.length > 0) {
        console.log(`  ðŸ“ Empty ItemTypes created: ${emptyItemTypesCreated.length}`);
    }
    if (errors.length > 0) {
        console.log(`  âŒ Errors: ${errors.length}`);
    }

    return {
        totalInserted,
        errors,
        barcodeConflicts,
        emptyItemTypesCreated,
        emptySubcategoriesCreated  // â­ NEW
    };
}

// ====================================================================================
// GENERATE COMPREHENSIVE REPORT
// ====================================================================================
function generateComprehensiveReport(brandName, validationData, seedResult) {
    if (!validationData) return null;

    const {
        products,
        validProducts,
        skippedNoName,
        duplicateCodes,
        duplicateBarcodes,
        productsRemovedDueToCodes,
        productsWithNullifiedBarcodes,
        autoGeneratedCodes,
        autoGeneratedBarcodes, // â­ Changed from emptyBarcodes
        itemTypesFound
    } = validationData;

    // Count by hierarchy
    const categoryCounts = {};
    const subcategoryCounts = {};
    const itemTypeCounts = {};

    for (const p of validProducts) {
        categoryCounts[p.category] = (categoryCounts[p.category] || 0) + 1;

        const subKey = `${p.category} > ${p.subcategory}`;
        subcategoryCounts[subKey] = (subcategoryCounts[subKey] || 0) + 1;

        const itemKey = `${p.category} > ${p.subcategory} > ${p.itemType}`;
        itemTypeCounts[itemKey] = (itemTypeCounts[itemKey] || 0) + 1;
    }

    // Add empty ItemTypes with count 0
    for (const item of itemTypesFound) {
        const itemKey = `${item.category} > ${item.subcategory} > ${item.itemType}`;
        if (!itemTypeCounts[itemKey]) {
            itemTypeCounts[itemKey] = 0;
        }
    }

    // Products with missing fields
    const missingCost = validProducts.filter(p => p.issues.includes('MISSING_COST'));
    const zeroQuantity = validProducts.filter(p => p.issues.includes('ZERO_QUANTITY'));

    return {
        summary: {
            totalRows: products.length,
            inserted: seedResult?.totalInserted || 0,
            skippedNoName: skippedNoName.length,
            duplicateCodesRemoved: productsRemovedDueToCodes.length,
            duplicateBarcodesSetNull: productsWithNullifiedBarcodes.length,
            autoGeneratedBarcodes: autoGeneratedBarcodes.length, // â­ Changed
            crossBrandBarcodeConflicts: seedResult?.barcodeConflicts?.length || 0,
            codesAutoGenerated: autoGeneratedCodes.length,
            emptyItemTypesCreated: seedResult?.emptyItemTypesCreated?.length || 0,
            errors: seedResult?.errors?.length || 0
        },
        counts: {
            categories: categoryCounts,
            subcategories: subcategoryCounts,
            itemTypes: itemTypeCounts
        },
        missingFields: {
            noCost: missingCost.length,
            zeroQuantity: zeroQuantity.length
        },
        duplicates: {
            codes: duplicateCodes,
            barcodes: duplicateBarcodes
        },
        skipped: {
            noName: skippedNoName
        },
        autoGeneratedCodes: autoGeneratedCodes,
        nullifiedBarcodes: productsWithNullifiedBarcodes,
        autoGeneratedBarcodes: autoGeneratedBarcodes, // â­ Changed from emptyBarcodes
        crossBrandBarcodeConflicts: seedResult?.barcodeConflicts || [],
        emptyItemTypes: seedResult?.emptyItemTypesCreated || [],
        insertionErrors: seedResult?.errors || [],
        detailedIssues: {
            missingCost,
            autoGeneratedCodes
        }
    };
}

// ====================================================================================
// EXPORT TEXT REPORT
// ====================================================================================
function exportTextReport(brandName, reportData) {
    if (!reportData) return;

    let output = '';

    output += 'â•'.repeat(120) + '\n';
    output += `${brandName} - COMPREHENSIVE DATA REPORT\n`;
    output += `Generated: ${new Date().toLocaleString('en-US', { timeZone: 'Africa/Cairo' })}\n`;
    output += 'â•'.repeat(120) + '\n\n';

    // SUMMARY
    output += 'ðŸ“Š SUMMARY\n';
    output += 'â”€'.repeat(120) + '\n';
    output += `Total Rows Processed:                           ${reportData.summary.totalRows}\n`;
    output += `âœ… Successfully Inserted:                        ${reportData.summary.inserted}\n`;
    output += `âŒ Insertion Errors:                             ${reportData.summary.errors}\n`;
    output += `âŒ Skipped (No Name):                            ${reportData.summary.skippedNoName}\n`;
    output += `âŒ Removed (Duplicate Codes in Excel):           ${reportData.summary.duplicateCodesRemoved} products\n`;
    output += `â­ Auto-Generated Codes:                         ${reportData.summary.codesAutoGenerated} products\n`;
    output += `â­ Barcodes Set to NULL (Duplicate in Excel):    ${reportData.summary.duplicateBarcodesSetNull} products\n`;
    output += `â­ Barcodes Auto-Generated (Empty in Excel):     ${reportData.summary.autoGeneratedBarcodes} products\n`;
    output += `âš ï¸  Barcodes Modified (Cross-Brand Conflict):    ${reportData.summary.crossBrandBarcodeConflicts} products (added DUPL suffix)\n`;
    output += `ðŸ“ Empty ItemTypes Created:                      ${reportData.summary.emptyItemTypesCreated}\n\n`;

    // Expected vs Actual
    const expected = reportData.summary.totalRows - reportData.summary.skippedNoName - reportData.summary.duplicateCodesRemoved;
    const actual = reportData.summary.inserted;


    output += `ðŸ“ CALCULATION:\n`;
    output += `  ${reportData.summary.totalRows} (total rows)\n`;
    output += `  - ${reportData.summary.skippedNoName} (no name)\n`;
    output += `  - ${reportData.summary.duplicateCodesRemoved} (duplicate codes removed)\n`;
    output += `  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
    output += `  = ${expected} (expected to insert)\n`;
    output += `  - ${reportData.summary.errors} (insertion errors)\n`;
    output += `  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
    output += `  = ${actual} (actually inserted)\n\n`;

    // HIERARCHY COUNTS
    output += 'â•'.repeat(120) + '\n';
    output += 'PRODUCT COUNTS BY HIERARCHY\n';
    output += 'â•'.repeat(120) + '\n\n';

    output += 'ðŸ“¦ CATEGORIES:\n';
    for (const [cat, count] of Object.entries(reportData.counts.categories)) {
        output += `  ${cat}: ${count} products\n`;
    }

    output += '\nðŸ“‚ SUBCATEGORIES:\n';
    for (const [sub, count] of Object.entries(reportData.counts.subcategories)) {
        output += `  ${sub}: ${count} products\n`;
    }

    output += '\nðŸ“ ITEM TYPES (All):\n';
    const sortedItems = Object.entries(reportData.counts.itemTypes).sort((a, b) => b[1] - a[1]);
    for (const [item, count] of sortedItems) {
        const indicator = count === 0 ? ' â­ EMPTY' : '';
        output += `  ${item}: ${count} products${indicator}\n`;
    }
    output += '\n';

    // EMPTY ITEM TYPES
    if (reportData.emptyItemTypes.length > 0) {
        output += 'â•'.repeat(120) + '\n';
        output += `â­ EMPTY ITEM TYPES CREATED - ${reportData.emptyItemTypes.length}\n`;
        output += 'â•'.repeat(120) + '\n';
        output += 'NOTE: These ItemTypes were found in Excel but have NO products.\n';
        output += 'They were created in the database structure.\n\n';

        reportData.emptyItemTypes.forEach((item, i) => {
            output += `${i + 1}. ${item.category} > ${item.subcategory} > ${item.itemType}\n`;
        });
        output += '\n';
    }

    // MISSING FIELDS SUMMARY
    output += 'â•'.repeat(120) + '\n';
    output += 'MISSING FIELDS SUMMARY\n';
    output += 'â•'.repeat(120) + '\n';
    output += `â­ Products with AUTO-GENERATED CODE:             ${reportData.missingFields.noCost}\n`;
    output += `â­ Products with AUTO-GENERATED BARCODE:          ${reportData.summary.autoGeneratedBarcodes}\n`; // â­ Changed    output += `âš ï¸  Products missing COST:                        ${reportData.missingFields.noCost}\n`;
    output += `â„¹ï¸  Products with ZERO quantity:                  ${reportData.missingFields.zeroQuantity}\n\n`;

    // AUTO-GENERATED CODES
    if (reportData.autoGeneratedCodes.length > 0) {
        output += 'â•'.repeat(120) + '\n';
        output += `â­ AUTO-GENERATED CODES - ${reportData.autoGeneratedCodes.length} PRODUCTS\n`;
        output += 'â•'.repeat(120) + '\n';
        output += 'NOTE: These products had NO CODE in Excel. Test codes were auto-generated.\n\n';

        reportData.autoGeneratedCodes.forEach((p, i) => {
            output += `${i + 1}. Row ${p.rowNumber}: ${p.name}\n`;
            output += `  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
            output += `  Original Code: ${p.originalCode || 'EMPTY'}\n`;
            output += `  Generated Code: ${p.code}\n`;
            output += `  Barcode: ${p.originalBarcode || 'NULL'}\n`;
            output += `  Location: ${p.subcategory} / ${p.itemType}\n`;
            output += `  âœ… STATUS: INSERTED WITH AUTO-GENERATED CODE\n\n`;
        });
    }

    // INSERTION ERRORS
    if (reportData.insertionErrors.length > 0) {
        output += 'â•'.repeat(120) + '\n';
        output += `âŒ INSERTION ERRORS - ${reportData.insertionErrors.length} PRODUCTS FAILED TO INSERT\n`;
        output += 'â•'.repeat(120) + '\n';
        output += 'NOTE: These products passed validation but failed during database insertion.\n\n';

        reportData.insertionErrors.forEach((err, i) => {
            output += `${i + 1}. Row ${err.rowNumber}: ${err.product}\n`;
            output += `  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
            output += `  Code: ${err.code}\n`;
            output += `  Barcode: ${err.barcode}\n`;
            output += `  Location: ${err.subcategory} / ${err.itemType}\n`;
            output += `  âŒ ERROR: ${err.error}\n`;
            if (err.conflictBrand) {
                output += `  âš ï¸  CONFLICT WITH: ${err.conflictBrand} brand (same code already exists)\n`;
            }
            output += '\n';
        });
    }

    // CROSS-BRAND BARCODE CONFLICTS
    if (reportData.crossBrandBarcodeConflicts.length > 0) {
        output += 'â•'.repeat(120) + '\n';
        output += `âš ï¸ CROSS-BRAND BARCODE CONFLICTS - ${reportData.crossBrandBarcodeConflicts.length} FOUND\n`;
        output += 'â•'.repeat(120) + '\n';
        output += 'NOTE: These products have barcodes that already exist in OTHER brands.\n';
        output += 'The barcode was MODIFIED by adding "DUPL" suffix.\n\n';

        reportData.crossBrandBarcodeConflicts.forEach((conflict, i) => {
            output += `${i + 1}. Row ${conflict.rowNumber}: ${conflict.productName}\n`;
            output += `  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
            output += `  Code: ${conflict.code}\n`;
            output += `  Original Barcode: ${conflict.originalBarcode}\n`;
            output += `  Modified Barcode: ${conflict.modifiedBarcode}\n`;
            output += `  âš ï¸  DUPLICATE BARCODE FOUND IN: ${conflict.conflictBrand} brand\n`;
            output += `  Conflicting Product: ${conflict.conflictProduct}\n`;
            output += `  Location: ${conflict.subcategory} / ${conflict.itemType}\n`;
            output += `  âœ… ACTION TAKEN: Added "DUPL" suffix to barcode, product inserted\n\n`;
        });
    }

    // DUPLICATE CODES IN EXCEL
    if (reportData.duplicates.codes.length > 0) {
        output += 'â•'.repeat(120) + '\n';
        output += `âŒ DUPLICATE CODES IN EXCEL - ${reportData.duplicates.codes.length} FOUND (ALL PRODUCTS REMOVED)\n`;
        output += 'â•'.repeat(120) + '\n';
        output += 'NOTE: When CODE is duplicated within the Excel sheet, ALL products with that code are REMOVED.\n';
        output += 'CODE must be unique - it is the primary identifier.\n\n';

        reportData.duplicates.codes.forEach(({ code, products }) => {
            output += `âŒ CODE: ${code} (used ${products.length} times - ALL ${products.length} PRODUCTS REMOVED)\n`;
            products.forEach((p, i) => {
                output += `  ${i + 1}. Row ${p.rowNumber}: ${p.name || '(NO NAME)'}\n`;
                output += `     Barcode: ${p.originalBarcode || 'EMPTY'}\n`;
                output += `     Location: ${p.subcategory} / ${p.itemType}\n`;
            });
            output += '\n';
        });
    }

    // DUPLICATE BARCODES IN EXCEL
    if (reportData.duplicates.barcodes.length > 0) {
        output += 'â•'.repeat(120) + '\n';
        output += `â­ DUPLICATE BARCODES IN EXCEL - ${reportData.duplicates.barcodes.length} FOUND\n`;
        output += 'â•'.repeat(120) + '\n';
        output += 'NOTE: When BARCODE is duplicated within the Excel sheet, barcode is SET TO NULL.\n';
        output += 'Products are inserted WITHOUT barcode.\n\n';

        reportData.duplicates.barcodes.forEach(({ barcode, products }) => {
            output += `â­ BARCODE: ${barcode} (used ${products.length} times)\n`;
            products.forEach((p, i) => {
                output += `  ${i + 1}. Row ${p.rowNumber}: ${p.name || '(NO NAME)'}\n`;
                output += `     Code: ${p.code}\n`;
                output += `     Original Barcode: ${p.originalBarcode}\n`;
                output += `     Modified Barcode: NULL\n`;
                output += `     Location: ${p.subcategory} / ${p.itemType}\n`;
                output += `     Status: âœ… PRODUCT INSERTED WITHOUT BARCODE\n`;
            });
            output += '\n';
        });
    }

    // SKIPPED NO NAME
    if (reportData.skipped.noName.length > 0) {
        output += 'â•'.repeat(120) + '\n';
        output += `âŒ SKIPPED - NO PRODUCT NAME (${reportData.skipped.noName.length})\n`;
        output += 'â•'.repeat(120) + '\n';
        output += 'NOTE: Products without a name are skipped even if they have other data.\n\n';

        reportData.skipped.noName.slice(0, 50).forEach((p, i) => {
            output += `${i + 1}. Row ${p.rowNumber}:\n`;
            output += `  Code: ${p.originalCode || 'EMPTY'}\n`;
            output += `  Barcode: ${p.originalBarcode || 'EMPTY'}\n`;
            output += `  Cost: ${p.cost}\n`;
            output += `  Quantity: ${p.quantity}\n`;
            output += `  Location: ${p.subcategory} / ${p.itemType}\n\n`;
        });

        if (reportData.skipped.noName.length > 50) {
            output += `... and ${reportData.skipped.noName.length - 50} more\n\n`;
        }
    }

    // EMPTY BARCODES
    // AUTO-GENERATED BARCODES
    if (reportData.autoGeneratedBarcodes && reportData.autoGeneratedBarcodes.length > 0) {
        output += 'â•'.repeat(120) + '\n';
        output += `â­ PRODUCTS WITH AUTO-GENERATED BARCODE (${reportData.autoGeneratedBarcodes.length})\n`;
        output += 'â•'.repeat(120) + '\n';
        output += 'NOTE: These products had NO barcode in Excel. Barcode was auto-generated from hierarchy.\n\n';

        reportData.autoGeneratedBarcodes.slice(0, 30).forEach((p, i) => {
            output += `${i + 1}. Row ${p.rowNumber}: ${p.name}\n`;
            output += `  Code: ${p.code}\n`;
            output += `  Generated Barcode: ${p.barcode}\n`;
            output += `  Location: ${p.subcategory} / ${p.itemType}\n`;
            output += `  âœ… STATUS: INSERTED WITH AUTO-GENERATED BARCODE\n\n`;
        });

        if (reportData.autoGeneratedBarcodes.length > 30) {
            output += `... and ${reportData.autoGeneratedBarcodes.length - 30} more\n\n`;
        }
    }


    // MISSING COST
    if (reportData.detailedIssues.missingCost.length > 0) {
        output += 'â•'.repeat(120) + '\n';
        output += `âš ï¸ PRODUCTS WITH MISSING COST (${reportData.detailedIssues.missingCost.length})\n`;
        output += 'â•'.repeat(120) + '\n\n';

        reportData.detailedIssues.missingCost.slice(0, 30).forEach((p, i) => {
            output += `${i + 1}. Row ${p.rowNumber}: ${p.name}\n`;
            output += `  Code: ${p.code}\n`;
            output += `  Location: ${p.subcategory} / ${p.itemType}\n\n`;
        });

        if (reportData.detailedIssues.missingCost.length > 30) {
            output += `... and ${reportData.detailedIssues.missingCost.length - 30} more\n\n`;
        }
    }

    output += 'â•'.repeat(120) + '\n';
    output += 'END OF REPORT\n';
    output += 'â•'.repeat(120) + '\n';

    // Save report
    fs.mkdirSync('./prisma/reports', { recursive: true });
    fs.writeFileSync(`./prisma/reports/${brandName}-Report.txt`, output, 'utf8');

    console.log(`  âœ… Report saved: prisma/reports/${brandName}-Report.txt`);
}

// ====================================================================================
// MAIN PROCESS
// ====================================================================================
async function processAllBrands() {
    console.log('\nðŸš€ STARTING COMPREHENSIVE PRODUCT SEEDING\n');
    console.log('Brands:', BRANDS.join(', '));

    for (const brand of BRANDS) {
        try {
            console.log('\n' + 'â•'.repeat(120));
            console.log(`PROCESSING: ${brand}`);
            console.log('â•'.repeat(120));

            // Step 1: Validate and preprocess
            const validationData = preprocessBrandData(brand);

            // Step 2: Seed valid products
            const seedResult = await seedBrand(brand, validationData);

            // Step 3: Generate report
            const reportData = generateComprehensiveReport(brand, validationData, seedResult);

            // Step 4: Export report
            exportTextReport(brand, reportData);

            // Store in global report
            globalReport.brands[brand] = reportData;
            globalReport.summary.totalProcessed += reportData?.summary.totalRows || 0;
            globalReport.summary.totalInserted += reportData?.summary.inserted || 0;
            globalReport.summary.totalSkipped += reportData?.summary.skippedNoName || 0;
            globalReport.summary.totalErrors += reportData?.summary.errors || 0;
            globalReport.summary.duplicateCodesRemoved += reportData?.summary.duplicateCodesRemoved || 0;
            globalReport.summary.duplicateBarcodesSetNull += reportData?.summary.duplicateBarcodesSetNull || 0;
            globalReport.summary.emptyBarcodesKeptNull += reportData?.summary.emptyBarcodesKeptNull || 0;
            globalReport.summary.crossBrandBarcodeConflicts += reportData?.summary.crossBrandBarcodeConflicts || 0;
            globalReport.summary.codesAutoGenerated += reportData?.summary.codesAutoGenerated || 0;
            globalReport.summary.emptyItemTypesCreated += reportData?.summary.emptyItemTypesCreated || 0;

        } catch (error) {
            console.error(`\nâŒ Error processing ${brand}:`, error.message);
        }
    }

    // Final Summary
    console.log('\n\n' + 'â•'.repeat(120));
    console.log('ðŸŽ‰ ALL BRANDS PROCESSED - FINAL SUMMARY');
    console.log('â•'.repeat(120));
    console.log('\n' + 'Brand'.padEnd(15) + 'Processed'.padEnd(12) + 'Inserted'.padEnd(12) + 'Errors'.padEnd(10) + 'No Name'.padEnd(12) + 'Dup Codes'.padEnd(15) + 'Null Barcodes'.padEnd(18) + 'Auto Codes'.padEnd(15) + 'Empty Items');
    console.log('â”€'.repeat(120));

    for (const brand of BRANDS) {
        const data = globalReport.brands[brand];
        if (data) {
            const totalNullBarcodes = (data.summary.duplicateBarcodesSetNull || 0) + (data.summary.emptyBarcodesKeptNull || 0);
            console.log(
                brand.padEnd(15) +
                data.summary.totalRows.toString().padEnd(12) +
                data.summary.inserted.toString().padEnd(12) +
                data.summary.errors.toString().padEnd(10) +
                data.summary.skippedNoName.toString().padEnd(12) +
                (data.summary.duplicateCodesRemoved + ' removed').padEnd(15) +
                (totalNullBarcodes + ' null').padEnd(18) +
                (data.summary.codesAutoGenerated + ' generated').padEnd(15) +
                (data.summary.emptyItemTypesCreated + ' empty')
            );
        }
    }

    console.log('â”€'.repeat(120));
    const totalNullBarcodes = globalReport.summary.duplicateBarcodesSetNull + globalReport.summary.emptyBarcodesKeptNull;
    console.log(
        'TOTAL'.padEnd(15) +
        globalReport.summary.totalProcessed.toString().padEnd(12) +
        globalReport.summary.totalInserted.toString().padEnd(12) +
        globalReport.summary.totalErrors.toString().padEnd(10) +
        globalReport.summary.totalSkipped.toString().padEnd(12) +
        (globalReport.summary.duplicateCodesRemoved + ' removed').padEnd(15) +
        (totalNullBarcodes + ' null').padEnd(18) +
        (globalReport.summary.codesAutoGenerated + ' generated').padEnd(15) +
        (globalReport.summary.emptyItemTypesCreated + ' empty')
    );
    console.log('â•'.repeat(120));
    console.log('\nâœ… All reports saved to: prisma/reports/\n');

    // Save global summary
    fs.writeFileSync(
        './prisma/reports/GLOBAL-SUMMARY.json',
        JSON.stringify(globalReport, null, 2),
        'utf8'
    );
}

// RUN
processAllBrands()
    .catch(console.error)
    .finally(() => prisma.$disconnect());
